#!/usr/bin/env ruby
#
# Convert D source file(s) into a single line of code.
#
# Copyright Â© 2023, Siarhei Siamashka
#
# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.


# This function "compiles" a D code snippet by trying to remove as many whitespaces as
# possible and producing a single line.
def preprocess_src(data)
  def remove_whitespaces(str)
    # test if there's a string literal
    if str =~ /(.*?)((\"\")|(\".*?[^\\]\"))(.*)/m
      part1 = $1
      string_literal = $2
      part2 = $5
      return remove_whitespaces(part1).strip + string_literal + remove_whitespaces(part2).strip
    else
      # collapse duplicate whitespaces
      str.gsub!(/\s+/m, " ")
      # collapse whitespaces around certain symbols
      str.gsub!(/\s*([\[\]\(\)\.\:\;\}\{\,\?])\s*/m, "\\1")
      # operators are a bit more tricky, because we don't want to convert "- -a" into "--a"
      op = '\>\<\=\+\-\*\/\|\&'
      str.gsub!(/([#{op}])\s+([^#{op}])/m, "\\1\\2")
      str.gsub!(/([^#{op}])\s+([#{op}])/m, "\\1\\2")
      return str
    end
  end

  # remove /* ... */ comments
  data.gsub!(/\/\*.*?\*\//m, " ")
  # remove /+ ... +/ comments
  data.gsub!(/\/\+.*?\+\//m, " ")
  # remove // ... comments
  data.gsub!(/\/\/.*?[\n\r]/m, " ")

  # remove redundant whitespaces
  data = remove_whitespaces(data).strip

  # remove the module declaration from the top
  data = $1 if data =~ /^module\s+[^\;]+\;(.*)$/m

  # remove imports, except for imports from the standard library (prefixed by std/core/ldc/gdc)
  # strip the 'private'/'public'/'package' prefix because it is meaningles in a single file
  data.gsub!(/(private\s+|public\s+|package\s+)?(import\s+([^\;]+\;))/m) do
    import_part = $2
    module_name = $3
    if module_name =~ /^(std[\.\s\;\:]|core[\.\s\;\:]|ldc[\.\s\;\:]|gdc[\.\s\;\:])/
      import_part
    else
      ";"
    end
  end

  return data
end

# some tests
abort "test failed" unless preprocess_src("a + b") == "a+b"
abort "test failed" unless preprocess_src("- -a") == "- -a"
abort "test failed" unless preprocess_src("module x; import foobar;") == ";"
abort "test failed" unless preprocess_src("module x; import std : writeln;") == "import std:writeln;"

sources = []

$describe = false
$strip_unittests = false

require "json"
ARGV.each do |arg|
  if arg =~ /^\-\-(.*)/
    case $1
      when "describe" then $describe = true
      when "strip-unittests" then $strip_unittests = true
      else abort "unknown option --#{$1}\n"
    end
  elsif arg =~ /dub\.json$/
    data = JSON.parse(File.read(arg))
    abort "bad json" unless data.has_key?("sourceFiles")
    data["sourceFiles"].each {|sourcefile| sources.push(File.join(File.dirname(arg), sourcefile)) }
  else
    sources.push(arg)
  end
end

puts sources.map {|filename| preprocess_src(File.read(filename)) }.join("")
