#!/usr/bin/env ruby
#
# Ask Clang to generate some LLVM IR for 128-bit arithmetics and wrap the
# produced results into inline LLVM IR code for LDC.
#
# Copyright Â© 2022, Siarhei Siamashka
#
# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

require "open3"

puts "// Automatically generated by the 'gen_int128_core_ldc.rb' script!

module speedy.int128_core_ldc;

version (LDC) {
import ldc.llvmasm;
import speedy.int128_core : Cent;

nothrow:
@safe:
@nogc:

pure
Cent ldc_divmod()(Cent c1, Cent c2, out Cent modulus)
{
    modulus = ldc_mod(c1, c2);
    return ldc_div(c1, c2);
}
"

def generate_function(code)
  tbl = {
    ["__int128", "__int128", "unsigned int"] =>
      ["pure\nCent", "()(Cent a, uint b)\n{\n\tauto tmp = __ir_pure!(`\n\t\t",
       "`, long[2])(a.lo, a.hi, b);\n\treturn Cent(tmp[0], tmp[1]);\n}\n"],

    ["__int128", "__int128", "__int128"] =>
      ["pure\nCent", "()(Cent a, Cent b)\n{\n\tauto tmp = __ir_pure!(`\n\t\t",
       "`, long[2])(a.lo, a.hi, b.lo, b.hi);\n\treturn Cent(tmp[0], tmp[1]);\n}\n"],

    ["__int128", "__int128"] =>
      ["pure\nCent", "()(Cent a)\n{\n\tauto tmp = __ir_pure!(`\n\t\t",
       "`, long[2])(a.lo, a.hi);\n\treturn Cent(tmp[0], tmp[1]);\n}\n"],

    ["int", "__int128", "__int128"] =>
      ["pure\nbool", "()(Cent a, Cent b)\n{\n\treturn cast(bool)__ir_pure!(`\n\t\t",
       "`, int)(a.lo, a.hi, b.lo, b.hi);\n}\n"],

    ["int", "__int128"] =>
      ["pure\nbool", "()(Cent a)\n{\n\treturn cast(bool)__ir_pure!(`\n\t\t",
       "`, int)(a.lo, a.hi);\n}\n"],
  }

#  o, s = Open3.capture2("clang --target=aarch64-unknown-linux-gnu -x c -O3 -emit-llvm -S - -o -", :stdin_data=>code)
#  o, s = Open3.capture2("clang --target=x86_64-pc-windows-msvc -x c -O3 -emit-llvm -S - -o -", :stdin_data=>code)
  o, s = Open3.capture2("clang --target=x86_64-pc-linux-gnu -x c -O3 -emit-llvm -S - -o -", :stdin_data=>code)
  abort "clang failed\n" unless s.success?

  abort "can't parse function type" unless code =~ /^([^\(]+)\s+([^\(]+)\(([^\)]+)/
  ret_type = $1.strip
  func_name = $2.strip
  arg_types = $3.strip.split(",").map {|s| s.split[0 .. -2].join(" ") }.to_a
  key = [ret_type] + arg_types
  abort "unsupported function type: #{key}\n" unless tbl.has_key?(key)

  found = false
  ir = []
  o.each_line do |l|
    if found
      break if l =~ /^\}/
      ir.push(l.strip)
    end
    found = true if l =~ /^define.*#{func_name}\(/
  end

  result = tbl[key][0] + " " + func_name + tbl[key][1] + ir.join("\n\t\t") + tbl[key][2]
  result.gsub!(/{ i64, i64 }/, "[ 2 x i64 ]")
  result.gsub!(/poison/, "undef")
  result.gsub!(/\t/, "    ")
  puts
  puts result
  return o
end

generate_function("__int128 ldc_shl(__int128 c, unsigned int n) { return c << n; }")
generate_function("__int128 ldc_shr(__int128 c, unsigned int n) { return ((unsigned __int128)c) >> n; }")
generate_function("__int128 ldc_sar(__int128 c, unsigned int n) { return c >> n; }")
generate_function("__int128 ldc_mul(__int128 a, __int128 b)     { return a * b; }")
generate_function("__int128 ldc_div(__int128 a, __int128 b)     { return a / b; }")
generate_function("__int128 ldc_mod(__int128 a, __int128 b)     { return a % b; }")
generate_function("__int128 ldc_xor(__int128 a, __int128 b)     { return a ^ b; }")
generate_function("__int128 ldc_and(__int128 a, __int128 b)     { return a & b; }")
generate_function("__int128 ldc_or(__int128 a, __int128 b)      { return a | b; }")
generate_function("__int128 ldc_add(__int128 a, __int128 b)     { return a + b; }")
generate_function("__int128 ldc_sub(__int128 a, __int128 b)     { return a - b; }")
generate_function("__int128 ldc_inc(__int128 a)                 { return ++a; }")
generate_function("__int128 ldc_dec(__int128 a)                 { return --a; }")
generate_function("__int128 ldc_neg(__int128 a)                 { return -a; }")
generate_function("__int128 ldc_com(__int128 a)                 { return ~a; }")
generate_function("int ldc_gt(__int128 a, __int128 b)           { return a > b; }")
generate_function("int ldc_tst(__int128 a)                      { return a != 0; }")

puts "\n} // version (LDC)"
