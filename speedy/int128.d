module speedy.int128;
/* code from https://github.com/ssvb/speedy-int128 (size: 24081, hash:37b62b5cd) */ version(all){;;public struct Int128{@safe pure nothrow @nogc:version(LDC){alias shl=ldc_shl;alias shr=ldc_shr;alias sar=ldc_sar;alias xor=ldc_xor;alias and=ldc_and;alias or=ldc_or;alias add=ldc_add;alias inc=ldc_inc;alias dec=ldc_dec;alias com=ldc_com;alias gt=ldc_gt;alias tst=ldc_tst;static if(size_t.sizeof==8){alias div=ldc_div;alias divmod=ldc_divmod;alias mul=ldc_mul;alias sub=ldc_sub;alias neg=ldc_neg;}else{alias div=core_div;alias divmod=core_divmod;version(ARM){alias mul=core_mul;alias sub=core_sub;alias neg=core_neg;}else{alias mul=ldc_mul;alias sub=ldc_sub;alias neg=ldc_neg;}}}else{alias shl=core_shl;alias shr=core_shr;alias sar=core_sar;alias xor=core_xor;alias and=core_and;alias or=core_or;alias add=core_add;alias inc=core_inc;alias dec=core_dec;alias com=core_com;alias gt=core_gt;alias tst=core_tst;alias div=core_div;alias divmod=core_divmod;alias mul=core_mul;alias sub=core_sub;alias neg=core_neg;}Cent data;pragma(inline,true)this(long lo){data.lo=lo;data.hi=lo<0?~0L:0;}pragma(inline,true)this(ulong lo){data.lo=lo;data.hi=0;}pragma(inline,true)this(long hi,long lo){data.hi=hi;data.lo=lo;}pragma(inline,true)this(Cent data){this.data=data;}pragma(inline,true)size_t toHash()const{return cast(size_t)((data.lo&0xFFFF_FFFF)+(data.hi&0xFFFF_FFFF)+(data.lo>>32)+(data.hi>>32));}pragma(inline,true)bool opEquals(long lo)const{return data.lo==lo&&data.hi==(lo>>63);}pragma(inline,true)bool opEquals(ulong lo)const{return data.hi==0&&data.lo==lo;}pragma(inline,true)bool opEquals(Int128 op2)const{return data.hi==op2.data.hi&&data.lo==op2.data.lo;}pragma(inline,true)Int128 opUnary(string op)()const if(op=="+"){return this;}pragma(inline,true)Int128 opUnary(string op)()const if(op=="-"||op=="~"){static if(op=="-")return Int128(neg(this.data));else static if(op=="~")return Int128(com(this.data));}pragma(inline,true)Int128 opUnary(string op)()if(op=="++"||op=="--"){static if(op=="++")this.data=inc(this.data);else static if(op=="--")this.data=dec(this.data);else static assert(0,op);return this;}pragma(inline,true)bool opCast(T:bool)()const{return tst(this.data);}pragma(inline,true)Int128 opBinary(string op)(Int128 op2)const if(op=="+"||op=="-"||op=="*"||op=="/"||op=="%"||op=="&"||op=="|"||op=="^"){static if(op=="+")return Int128(add(this.data,op2.data));else static if(op=="-")return Int128(sub(this.data,op2.data));else static if(op=="*")return Int128(mul(this.data,op2.data));else static if(op=="/")return Int128(div(this.data,op2.data));else static if(op=="%"){Cent modulus;divmod(this.data,op2.data,modulus);return Int128(modulus);}else static if(op=="&")return Int128(and(this.data,op2.data));else static if(op=="|")return Int128(or(this.data,op2.data));else static if(op=="^")return Int128(xor(this.data,op2.data));else static assert(0,"wrong op value");}pragma(inline,true)Int128 opBinary(string op)(long op2)const if(op=="+"||op=="-"||op=="*"||op=="/"||op=="%"||op=="&"||op=="|"||op=="^"){return mixin("this "~ op ~" Int128(0, op2)");}pragma(inline,true)Int128 opBinaryRight(string op)(long op2)const if(op=="+"||op=="-"||op=="*"||op=="/"||op=="%"||op=="&"||op=="|"||op=="^"){mixin("return Int128(0, op2) "~ op ~" this;");}pragma(inline,true)Int128 opBinary(string op)(long op2)const if(op=="<<"){return Int128(shl(this.data,cast(uint)op2));}pragma(inline,true)Int128 opBinary(string op)(long op2)const if(op==">>"){return Int128(sar(this.data,cast(uint)op2));}pragma(inline,true)Int128 opBinary(string op)(long op2)const if(op==">>>"){return Int128(shr(this.data,cast(uint)op2));}pragma(inline,true)ref Int128 opOpAssign(string op)(Int128 op2)if(op=="+"||op=="-"||op=="*"||op=="/"||op=="%"||op=="&"||op=="|"||op=="^"||op=="<<"||op==">>"||op==">>>"){mixin("this = this "~ op ~" op2;");return this;}pragma(inline,true)ref Int128 opOpAssign(string op)(long op2)if(op=="+"||op=="-"||op=="*"||op=="/"||op=="%"||op=="&"||op=="|"||op=="^"||op=="<<"||op==">>"||op==">>>"){mixin("this = this "~ op ~" op2;");return this;}pragma(inline,true)int opCmp(Int128 op2)const{return this==op2?0:gt(this.data,op2.data)*2-1;}pragma(inline,true)int opCmp(long op2)const{return opCmp(Int128(0,op2));}enum min=Int128(long.min,0);enum max=Int128(long.max,ulong.max);}version(unittest){import core.stdc.stdio;@trusted void print(Int128 c){printf("%lld, %lld\n",c.data.hi,c.data.lo);}@trusted void printx(Int128 c){printf("%llx, %llx\n",c.data.hi,c.data.lo);}}@safe pure nothrow @nogc unittest{Int128 c=Int128(5,6);assert(c==c);assert(c== +c);assert(c== - -c);assert(~c==Int128(~5,~6));++c;assert(c==Int128(5,7));assert(--c==Int128(5,6));assert(!!c);assert(!Int128());assert(c+Int128(10,20)==Int128(15,26));assert(c-Int128(1,2)==Int128(4,4));assert(c*Int128(100,2)==Int128(610,12));assert(c/Int128(3,2)==Int128(0,1));assert(c % Int128(3,2)==Int128(2,4));assert((c&Int128(3,2))==Int128(1,2));assert((c|Int128(3,2))==Int128(7,6));assert((c ^ Int128(3,2))==Int128(6,4));assert(c+15==Int128(5,21));assert(c-15==Int128(4,-9));assert(c*15==Int128(75,90));assert(c/15==Int128(0,6148914691236517205));assert(c % 15==Int128(0,11));assert((c&15)==Int128(0,6));assert((c|15)==Int128(5,15));assert((c ^ 15)==Int128(5,9));assert(15+c==Int128(5,21));assert(15-c==Int128(-5,9));assert(15*c==Int128(75,90));assert(15/c==Int128(0,0));assert(15 % c==Int128(0,15));assert((15&c)==Int128(0,6));assert((15|c)==Int128(5,15));assert((15 ^ c)==Int128(5,9));assert(c<<1==Int128(10,12));assert(-c>>1==Int128(-3,9223372036854775805));assert(-c>>>1==Int128(9223372036854775805,9223372036854775805));assert((c+=1)==Int128(5,7));assert((c-=1)==Int128(5,6));assert((c+=Int128(0,1))==Int128(5,7));assert((c-=Int128(0,1))==Int128(5,6));assert((c*=2)==Int128(10,12));assert((c/=2)==Int128(5,6));assert((c %=2)==Int128());c+=Int128(5,6);assert((c*=Int128(10,20))==Int128(160,120));assert((c/=Int128(10,20))==Int128(0,15));c+=Int128(72,0);assert((c %=Int128(10,20))==Int128(1,-125));assert((c&=Int128(3,20))==Int128(1,0));assert((c|=Int128(8,2))==Int128(9,2));assert((c ^=Int128(8,2))==Int128(1,0));c|=Int128(10,5);assert((c<<=1)==Int128(11*2,5*2));assert((c>>>=1)==Int128(11,5));c=Int128(long.min,long.min);assert((c>>=1)==Int128(long.min>>1,cast(ulong)long.min>>1));assert(-Int128.min==Int128.min);assert(Int128.max+1==Int128.min);c=Int128(5,6);assert(c<Int128(6,5));assert(c>10);c=Int128(-1UL);assert(c== -1UL);c=Int128(-1L);assert(c== -1L);}}version(all){version(LDC){import ldc.llvmasm;;nothrow:@safe:@nogc:pragma(inline,true)pure Cent ldc_divmod()(Cent c1,Cent c2,out Cent modulus){modulus=ldc_mod(c1,c2);return ldc_div(c1,c2);}pragma(inline,true)pure Cent ldc_shl()(Cent a,uint b){auto tmp=__ir_pure!(` %4=zext i64 %1 to i128 %5=shl nuw i128 %4,64 %6=zext i64 %0 to i128 %7=or i128 %5,%6 %8=zext i32 %2 to i128 %9=shl i128 %7,%8 %10=trunc i128 %9 to i64 %11=lshr i128 %9,64 %12=trunc i128 %11 to i64 %13=insertvalue[2 x i64]undef,i64 %10,0 %14=insertvalue[2 x i64]%13,i64 %12,1 ret[2 x i64]%14`,long[2])(a.lo,a.hi,b);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_shr()(Cent a,uint b){auto tmp=__ir_pure!(` %4=zext i64 %1 to i128 %5=shl nuw i128 %4,64 %6=zext i64 %0 to i128 %7=or i128 %5,%6 %8=zext i32 %2 to i128 %9=lshr i128 %7,%8 %10=trunc i128 %9 to i64 %11=lshr i128 %9,64 %12=trunc i128 %11 to i64 %13=insertvalue[2 x i64]undef,i64 %10,0 %14=insertvalue[2 x i64]%13,i64 %12,1 ret[2 x i64]%14`,long[2])(a.lo,a.hi,b);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_sar()(Cent a,uint b){auto tmp=__ir_pure!(` %4=zext i64 %1 to i128 %5=shl nuw i128 %4,64 %6=zext i64 %0 to i128 %7=or i128 %5,%6 %8=zext i32 %2 to i128 %9=ashr i128 %7,%8 %10=trunc i128 %9 to i64 %11=lshr i128 %9,64 %12=trunc i128 %11 to i64 %13=insertvalue[2 x i64]undef,i64 %10,0 %14=insertvalue[2 x i64]%13,i64 %12,1 ret[2 x i64]%14`,long[2])(a.lo,a.hi,b);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_mul()(Cent a,Cent b){auto tmp=__ir_pure!(` %5=zext i64 %1 to i128 %6=shl nuw i128 %5,64 %7=zext i64 %0 to i128 %8=or i128 %6,%7 %9=zext i64 %3 to i128 %10=shl nuw i128 %9,64 %11=zext i64 %2 to i128 %12=or i128 %10,%11 %13=mul nsw i128 %12,%8 %14=trunc i128 %13 to i64 %15=lshr i128 %13,64 %16=trunc i128 %15 to i64 %17=insertvalue[2 x i64]undef,i64 %14,0 %18=insertvalue[2 x i64]%17,i64 %16,1 ret[2 x i64]%18`,long[2])(a.lo,a.hi,b.lo,b.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_div()(Cent a,Cent b){auto tmp=__ir_pure!(` %5=zext i64 %1 to i128 %6=shl nuw i128 %5,64 %7=zext i64 %0 to i128 %8=or i128 %6,%7 %9=zext i64 %3 to i128 %10=shl nuw i128 %9,64 %11=zext i64 %2 to i128 %12=or i128 %10,%11 %13=sdiv i128 %8,%12 %14=trunc i128 %13 to i64 %15=lshr i128 %13,64 %16=trunc i128 %15 to i64 %17=insertvalue[2 x i64]undef,i64 %14,0 %18=insertvalue[2 x i64]%17,i64 %16,1 ret[2 x i64]%18`,long[2])(a.lo,a.hi,b.lo,b.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_mod()(Cent a,Cent b){auto tmp=__ir_pure!(` %5=zext i64 %1 to i128 %6=shl nuw i128 %5,64 %7=zext i64 %0 to i128 %8=or i128 %6,%7 %9=zext i64 %3 to i128 %10=shl nuw i128 %9,64 %11=zext i64 %2 to i128 %12=or i128 %10,%11 %13=srem i128 %8,%12 %14=trunc i128 %13 to i64 %15=lshr i128 %13,64 %16=trunc i128 %15 to i64 %17=insertvalue[2 x i64]undef,i64 %14,0 %18=insertvalue[2 x i64]%17,i64 %16,1 ret[2 x i64]%18`,long[2])(a.lo,a.hi,b.lo,b.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_xor()(Cent a,Cent b){auto tmp=__ir_pure!(` %5=zext i64 %1 to i128 %6=shl nuw i128 %5,64 %7=zext i64 %0 to i128 %8=or i128 %6,%7 %9=zext i64 %3 to i128 %10=shl nuw i128 %9,64 %11=zext i64 %2 to i128 %12=or i128 %10,%11 %13=xor i128 %12,%8 %14=trunc i128 %13 to i64 %15=lshr i128 %13,64 %16=trunc i128 %15 to i64 %17=insertvalue[2 x i64]undef,i64 %14,0 %18=insertvalue[2 x i64]%17,i64 %16,1 ret[2 x i64]%18`,long[2])(a.lo,a.hi,b.lo,b.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_and()(Cent a,Cent b){auto tmp=__ir_pure!(` %5=zext i64 %1 to i128 %6=shl nuw i128 %5,64 %7=zext i64 %0 to i128 %8=or i128 %6,%7 %9=zext i64 %3 to i128 %10=shl nuw i128 %9,64 %11=zext i64 %2 to i128 %12=or i128 %10,%11 %13=and i128 %12,%8 %14=trunc i128 %13 to i64 %15=lshr i128 %13,64 %16=trunc i128 %15 to i64 %17=insertvalue[2 x i64]undef,i64 %14,0 %18=insertvalue[2 x i64]%17,i64 %16,1 ret[2 x i64]%18`,long[2])(a.lo,a.hi,b.lo,b.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_or()(Cent a,Cent b){auto tmp=__ir_pure!(` %5=zext i64 %1 to i128 %6=shl nuw i128 %5,64 %7=zext i64 %0 to i128 %8=or i128 %6,%7 %9=zext i64 %3 to i128 %10=shl nuw i128 %9,64 %11=zext i64 %2 to i128 %12=or i128 %10,%11 %13=or i128 %12,%8 %14=trunc i128 %13 to i64 %15=lshr i128 %13,64 %16=trunc i128 %15 to i64 %17=insertvalue[2 x i64]undef,i64 %14,0 %18=insertvalue[2 x i64]%17,i64 %16,1 ret[2 x i64]%18`,long[2])(a.lo,a.hi,b.lo,b.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_add()(Cent a,Cent b){auto tmp=__ir_pure!(` %5=zext i64 %1 to i128 %6=shl nuw i128 %5,64 %7=zext i64 %0 to i128 %8=zext i64 %3 to i128 %9=shl nuw i128 %8,64 %10=zext i64 %2 to i128 %11=or i128 %6,%7 %12=add i128 %11,%10 %13=add i128 %12,%9 %14=trunc i128 %13 to i64 %15=lshr i128 %13,64 %16=trunc i128 %15 to i64 %17=insertvalue[2 x i64]undef,i64 %14,0 %18=insertvalue[2 x i64]%17,i64 %16,1 ret[2 x i64]%18`,long[2])(a.lo,a.hi,b.lo,b.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_sub()(Cent a,Cent b){auto tmp=__ir_pure!(` %5=zext i64 %1 to i128 %6=shl nuw i128 %5,64 %7=zext i64 %0 to i128 %8=zext i64 %3 to i128 %9=mul i128 %8,-18446744073709551616 %10=zext i64 %2 to i128 %11=or i128 %6,%7 %12=sub i128 %11,%10 %13=add i128 %12,%9 %14=trunc i128 %13 to i64 %15=lshr i128 %13,64 %16=trunc i128 %15 to i64 %17=insertvalue[2 x i64]undef,i64 %14,0 %18=insertvalue[2 x i64]%17,i64 %16,1 ret[2 x i64]%18`,long[2])(a.lo,a.hi,b.lo,b.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_inc()(Cent a){auto tmp=__ir_pure!(` %3=zext i64 %1 to i128 %4=shl nuw i128 %3,64 %5=zext i64 %0 to i128 %6=add nuw nsw i128 %5,1 %7=add i128 %6,%4 %8=trunc i128 %7 to i64 %9=lshr i128 %7,64 %10=trunc i128 %9 to i64 %11=insertvalue[2 x i64]undef,i64 %8,0 %12=insertvalue[2 x i64]%11,i64 %10,1 ret[2 x i64]%12`,long[2])(a.lo,a.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_dec()(Cent a){auto tmp=__ir_pure!(` %3=zext i64 %1 to i128 %4=shl nuw i128 %3,64 %5=zext i64 %0 to i128 %6=add nsw i128 %5,-1 %7=add i128 %6,%4 %8=trunc i128 %7 to i64 %9=lshr i128 %7,64 %10=trunc i128 %9 to i64 %11=insertvalue[2 x i64]undef,i64 %8,0 %12=insertvalue[2 x i64]%11,i64 %10,1 ret[2 x i64]%12`,long[2])(a.lo,a.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_neg()(Cent a){auto tmp=__ir_pure!(` %3=zext i64 %1 to i128 %4=mul i128 %3,-18446744073709551616 %5=zext i64 %0 to i128 %6=sub i128 %4,%5 %7=trunc i128 %6 to i64 %8=lshr i128 %6,64 %9=trunc i128 %8 to i64 %10=insertvalue[2 x i64]undef,i64 %7,0 %11=insertvalue[2 x i64]%10,i64 %9,1 ret[2 x i64]%11`,long[2])(a.lo,a.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure Cent ldc_com()(Cent a){auto tmp=__ir_pure!(` %3=zext i64 %1 to i128 %4=shl nuw i128 %3,64 %5=zext i64 %0 to i128 %6=or i128 %4,%5 %7=xor i128 %6,-1 %8=trunc i128 %7 to i64 %9=lshr i128 %7,64 %10=trunc i128 %9 to i64 %11=insertvalue[2 x i64]undef,i64 %8,0 %12=insertvalue[2 x i64]%11,i64 %10,1 ret[2 x i64]%12`,long[2])(a.lo,a.hi);return Cent(tmp[0],tmp[1]);}pragma(inline,true)pure bool ldc_gt()(Cent a,Cent b){return cast(bool)__ir_pure!(` %5=zext i64 %1 to i128 %6=shl nuw i128 %5,64 %7=zext i64 %0 to i128 %8=or i128 %6,%7 %9=zext i64 %3 to i128 %10=shl nuw i128 %9,64 %11=zext i64 %2 to i128 %12=or i128 %10,%11 %13=icmp sgt i128 %8,%12 %14=zext i1 %13 to i32 ret i32 %14`,int)(a.lo,a.hi,b.lo,b.hi);}pragma(inline,true)pure bool ldc_tst()(Cent a){return cast(bool)__ir_pure!(` %3=zext i64 %1 to i128 %4=shl nuw i128 %3,64 %5=zext i64 %0 to i128 %6=or i128 %4,%5 %7=icmp ne i128 %6,0 %8=zext i1 %7 to i32 ret i32 %8`,int)(a.lo,a.hi);}}}version(all){nothrow:@safe:@nogc:alias I=long;alias U=ulong;enum Ubits=uint(U.sizeof*8);struct Cent{version(LittleEndian){U lo;U hi;}else{U hi;U lo;}}enum Cent One={lo:1};enum Cent Zero={lo:0};enum Cent MinusOne=core_neg(One);pure bool core_tst(Cent c){return c.hi||c.lo;}pure Cent core_com(Cent c){c.lo=~c.lo;c.hi=~c.hi;return c;}pure Cent core_neg(Cent c){if(c.lo==0)c.hi= -c.hi;else{c.lo= -c.lo;c.hi=~c.hi;}return c;}pure Cent core_inc(Cent c){return core_add(c,One);}pure Cent core_dec(Cent c){return core_sub(c,One);}pure Cent shl1(Cent c){c.hi=(c.hi<<1)|(cast(I)c.lo<0);c.lo<<=1;return c;}pure Cent shr1(Cent c){c.lo=(c.lo>>1)|((c.hi&1)<<(Ubits-1));c.hi>>=1;return c;}pure Cent sar1(Cent c){c.lo=(c.lo>>1)|((c.hi&1)<<(Ubits-1));c.hi=cast(I)c.hi>>1;return c;}pure Cent core_shl(Cent c,uint n){if(n>=Ubits*2)return Zero;if(n>=Ubits){c.hi=c.lo<<(n-Ubits);c.lo=0;}else{c.hi=((c.hi<<n)|(c.lo>>(Ubits-n-1)>>1));c.lo=c.lo<<n;}return c;}pure Cent core_shr(Cent c,uint n){if(n>=Ubits*2)return Zero;if(n>=Ubits){c.lo=c.hi>>(n-Ubits);c.hi=0;}else{c.lo=((c.lo>>n)|(c.hi<<(Ubits-n-1)<<1));c.hi=c.hi>>n;}return c;}pure Cent core_sar(Cent c,uint n){const signmask= -(c.hi>>(Ubits-1));const signshift=(Ubits*2)-n;c=core_shr(c,n);if(n>=Ubits*2){c.hi=signmask;c.lo=signmask;}else if(signshift>=Ubits*2){}else if(signshift>=Ubits){c.hi&=~(U.max<<(signshift-Ubits));c.hi|=signmask<<(signshift-Ubits);}else{c.hi=signmask;c.lo&=~(U.max<<signshift);c.lo|=signmask<<signshift;}return c;}pure Cent rol1(Cent c){int carry=cast(I)c.hi<0;c.hi=(c.hi<<1)|(cast(I)c.lo<0);c.lo=(c.lo<<1)|carry;return c;}pure Cent ror1(Cent c){int carry=c.lo&1;c.lo=(c.lo>>1)|(cast(U)(c.hi&1)<<(Ubits-1));c.hi=(c.hi>>1)|(cast(U)carry<<(Ubits-1));return c;}pure Cent rol(Cent c,uint n){n&=Ubits*2-1;Cent l=core_shl(c,n);Cent r=core_shr(c,Ubits*2-n);return core_or(l,r);}pure Cent ror(Cent c,uint n){n&=Ubits*2-1;Cent r=core_shr(c,n);Cent l=core_shl(c,Ubits*2-n);return core_or(r,l);}pure Cent core_and(Cent c1,Cent c2){const Cent ret={lo:c1.lo&c2.lo,hi:c1.hi&c2.hi};return ret;}pure Cent core_or(Cent c1,Cent c2){const Cent ret={lo:c1.lo|c2.lo,hi:c1.hi|c2.hi};return ret;}pure Cent core_xor(Cent c1,Cent c2){const Cent ret={lo:c1.lo ^ c2.lo,hi:c1.hi ^ c2.hi};return ret;}pure Cent core_add(Cent c1,Cent c2){U r=cast(U)(c1.lo+c2.lo);const Cent ret={lo:r,hi:cast(U)(c1.hi+c2.hi+(r<c1.lo))};return ret;}pure Cent core_sub(Cent c1,Cent c2){return core_add(c1,core_neg(c2));}pure Cent core_mul(Cent c1,Cent c2){enum mulmask=(1UL<<(Ubits/2))-1;enum mulshift=Ubits/2;const c2l0=c2.lo&mulmask;const c2l1=c2.lo>>mulshift;const c2h0=c2.hi&mulmask;const c2h1=c2.hi>>mulshift;const c1l0=c1.lo&mulmask;U r0=c1l0*c2l0;U r1=c1l0*c2l1+(r0>>mulshift);U r2=c1l0*c2h0+(r1>>mulshift);U r3=c1l0*c2h1+(r2>>mulshift);const c1l1=c1.lo>>mulshift;r1=c1l1*c2l0+(r1&mulmask);r2=c1l1*c2l1+(r2&mulmask)+(r1>>mulshift);r3=c1l1*c2h0+(r3&mulmask)+(r2>>mulshift);const c1h0=c1.hi&mulmask;r2=c1h0*c2l0+(r2&mulmask);r3=c1h0*c2l1+(r3&mulmask)+(r2>>mulshift);const c1h1=c1.hi>>mulshift;r3=c1h1*c2l0+(r3&mulmask);const Cent ret={lo:(r0&mulmask)+(r1&mulmask)*(mulmask+1),hi:(r2&mulmask)+(r3&mulmask)*(mulmask+1)};return ret;}pure Cent udiv(Cent c1,Cent c2){Cent modulus;return udivmod(c1,c2,modulus);}pure Cent udivmod(Cent c1,Cent c2,out Cent modulus){import core.bitop;static U udivmod128_64(Cent c1,U c2,out U modulus){enum base=1UL<<32;enum divmask=(1UL<<(Ubits/2))-1;enum divshift=Ubits/2;if(c1.hi>=c2){modulus=0UL;return ~0UL;}static uint udiv96_64(U num1,uint num0,U den){const den1=cast(uint)(den>>divshift);const den0=cast(uint)(den&divmask);U ret=num1/den1;const t2=(num1 % den1)*base+num0;const t1=ret*den0;if(t1>t2)ret-=(t1-t2>den)?2:1;return cast(uint)ret;}const shift=(Ubits-1)-bsr(c2);c2<<=shift;U num2=c1.hi;num2<<=shift;num2|=(c1.lo>>(-shift&63))&(-cast(I)shift>>63);c1.lo<<=shift;const num1=cast(uint)(c1.lo>>divshift);const num0=cast(uint)(c1.lo&divmask);const q1=udiv96_64(num2,num1,c2);const rem=num2*base+num1-q1*c2;const q0=udiv96_64(rem,num0,c2);modulus=(rem*base+num0-q0*c2)>>shift;return(cast(U)q1<<divshift)|q0;}if(!core_tst(c2)){modulus=Zero;return core_com(modulus);}if(c1.hi==0&&c2.hi==0){const Cent rem={lo:c1.lo % c2.lo};modulus=rem;const Cent ret={lo:c1.lo/c2.lo};return ret;}if(c1.hi==0){modulus=c1;return Zero;}if(c2.hi==0){const q1=(c1.hi<c2.lo)?0:(c1.hi/c2.lo);if(q1)c1.hi=c1.hi % c2.lo;Cent rem;const q0=udivmod128_64(c1,c2.lo,rem.lo);modulus=rem;const Cent ret={lo:q0,hi:q1};return ret;}const shift=(Ubits-1)-bsr(c2.hi);U v1=core_shl(c2,shift).hi;Cent u1=shr1(c1);U rem_ignored;const Cent q1={lo:udivmod128_64(u1,v1,rem_ignored)};Cent quotient=core_shr(core_shl(q1,shift),63);if(core_tst(quotient))quotient=core_dec(quotient);Cent rem=core_sub(c1,core_mul(quotient,c2));if(uge(rem,c2)){quotient=core_inc(quotient);rem=core_sub(rem,c2);}modulus=rem;return quotient;}pure Cent core_div(Cent c1,Cent c2){Cent modulus;return core_divmod(c1,c2,modulus);}pure Cent core_divmod(Cent c1,Cent c2,out Cent modulus){if(cast(I)c1.hi<0){if(cast(I)c2.hi<0){Cent r=udivmod(core_neg(c1),core_neg(c2),modulus);modulus=core_neg(modulus);return r;}Cent r=core_neg(udivmod(core_neg(c1),c2,modulus));modulus=core_neg(modulus);return r;}else if(cast(I)c2.hi<0){return core_neg(udivmod(c1,core_neg(c2),modulus));}else return udivmod(c1,c2,modulus);}pure bool ugt(Cent c1,Cent c2){return(c1.hi==c2.hi)?(c1.lo>c2.lo):(c1.hi>c2.hi);}pure bool uge(Cent c1,Cent c2){return !ugt(c2,c1);}pure bool ult(Cent c1,Cent c2){return ugt(c2,c1);}pure bool ule(Cent c1,Cent c2){return !ugt(c1,c2);}pure bool core_gt(Cent c1,Cent c2){return(c1.hi==c2.hi)?(c1.lo>c2.lo):(cast(I)c1.hi>cast(I)c2.hi);}pure bool ge(Cent c1,Cent c2){return !core_gt(c2,c1);}pure bool lt(Cent c1,Cent c2){return core_gt(c2,c1);}pure bool le(Cent c1,Cent c2){return !core_gt(c1,c2);}version(unittest){version(none){import core.stdc.stdio;@trusted void print(Cent c){printf("%lld, %lld\n",cast(ulong)c.lo,cast(ulong)c.hi);printf("x%llx, x%llx\n",cast(ulong)c.lo,cast(ulong)c.hi);}}}unittest{const Cent C0=Zero;const Cent C1=One;const Cent C2={lo:2};const Cent C3={lo:3};const Cent C5={lo:5};const Cent C10={lo:10};const Cent C20={lo:20};const Cent C30={lo:30};const Cent C100={lo:100};const Cent Cm1=core_neg(One);const Cent Cm3=core_neg(C3);const Cent Cm10=core_neg(C10);const Cent C3_1={lo:1,hi:3};const Cent C3_2={lo:2,hi:3};const Cent C4_8={lo:8,hi:4};const Cent C5_0={lo:0,hi:5};const Cent C7_1={lo:1,hi:7};const Cent C7_9={lo:9,hi:7};const Cent C9_3={lo:3,hi:9};const Cent C10_0={lo:0,hi:10};const Cent C10_1={lo:1,hi:10};const Cent C10_3={lo:3,hi:10};const Cent C11_3={lo:3,hi:11};const Cent C20_0={lo:0,hi:20};const Cent C90_30={lo:30,hi:90};const Cent Cm10_0=core_inc(core_com(C10_0));const Cent Cm10_1=core_inc(core_com(C10_1));const Cent Cm10_3=core_inc(core_com(C10_3));const Cent Cm20_0=core_inc(core_com(C20_0));enum Cent Cs_3={lo:3,hi:I.min};const Cent Cbig_1={lo:0xa3ccac1832952398,hi:0xc3ac542864f652f8};const Cent Cbig_2={lo:0x5267b85f8a42fc20,hi:0};const Cent Cbig_3={lo:0xf0000000ffffffff,hi:0};assert(ugt(C1,C0));assert(ult(C1,C2));assert(uge(C1,C0));assert(ule(C1,C2));assert(!ugt(C0,C1));assert(!ult(C2,C1));assert(!uge(C0,C1));assert(!ule(C2,C1));assert(!ugt(C1,C1));assert(!ult(C1,C1));assert(uge(C1,C1));assert(ule(C2,C2));assert(ugt(C10_3,C10_1));assert(ugt(C11_3,C10_3));assert(!ugt(C9_3,C10_3));assert(!ugt(C9_3,C9_3));assert(core_gt(C2,C1));assert(!core_gt(C1,C2));assert(!core_gt(C1,C1));assert(core_gt(C0,Cm1));assert(core_gt(Cm1,core_neg(C10)));assert(!core_gt(Cm1,Cm1));assert(!core_gt(Cm1,C0));assert(!lt(C2,C1));assert(!le(C2,C1));assert(ge(C2,C1));assert(core_neg(C10_0)==Cm10_0);assert(core_neg(C10_1)==Cm10_1);assert(core_neg(C10_3)==Cm10_3);assert(core_add(C7_1,C3_2)==C10_3);assert(core_sub(C1,C2)==Cm1);assert(core_inc(C3_1)==C3_2);assert(core_dec(C3_2)==C3_1);assert(core_shl(C10,0)==C10);assert(core_shl(C10,Ubits)==C10_0);assert(core_shl(C10,1)==C20);assert(core_shl(C10,Ubits*2)==C0);assert(core_shr(C10_0,0)==C10_0);assert(core_shr(C10_0,Ubits)==C10);assert(core_shr(C10_0,Ubits-1)==C20);assert(core_shr(C10_0,Ubits+1)==C5);assert(core_shr(C10_0,Ubits*2)==C0);assert(core_sar(C10_0,0)==C10_0);assert(core_sar(C10_0,Ubits)==C10);assert(core_sar(C10_0,Ubits-1)==C20);assert(core_sar(C10_0,Ubits+1)==C5);assert(core_sar(C10_0,Ubits*2)==C0);assert(core_sar(Cm1,Ubits*2)==Cm1);assert(shl1(C10)==C20);assert(shr1(C10_0)==C5_0);assert(sar1(C10_0)==C5_0);assert(sar1(Cm1)==Cm1);Cent modulus;assert(udiv(C10,C2)==C5);assert(udivmod(C10,C2,modulus)==C5);assert(modulus==C0);assert(udivmod(C10,C3,modulus)==C3);assert(modulus==C1);assert(udivmod(C10,C0,modulus)==Cm1);assert(modulus==C0);assert(udivmod(C2,C90_30,modulus)==C0);assert(modulus==C2);assert(udiv(core_mul(C90_30,C2),C2)==C90_30);assert(udiv(core_mul(C90_30,C2),C90_30)==C2);assert(core_div(C10,C3)==C3);assert(core_divmod(C10,C3,modulus)==C3);assert(modulus==C1);assert(core_divmod(Cm10,C3,modulus)==Cm3);assert(modulus==Cm1);assert(core_divmod(C10,Cm3,modulus)==Cm3);assert(modulus==C1);assert(core_divmod(Cm10,Cm3,modulus)==C3);assert(modulus==Cm1);assert(core_divmod(C2,C90_30,modulus)==C0);assert(modulus==C2);assert(core_div(core_mul(C90_30,C2),C2)==C90_30);assert(core_div(core_mul(C90_30,C2),C90_30)==C2);const Cent Cb1divb2={lo:0x4496aa309d4d4a2f,hi:U.max};const Cent Cb1modb2={lo:0xd83203d0fdc799b8,hi:U.max};assert(core_divmod(Cbig_1,Cbig_2,modulus)==Cb1divb2);assert(modulus==Cb1modb2);const Cent Cb1udivb2={lo:0x5fe0e9bace2bedad,hi:2};const Cent Cb1umodb2={lo:0x2c923125a68721f8,hi:0};assert(udivmod(Cbig_1,Cbig_2,modulus)==Cb1udivb2);assert(modulus==Cb1umodb2);const Cent Cb1divb3={lo:0xbfa6c02b5aff8b86,hi:U.max};const Cent Cb1udivb3={lo:0xd0b7d13b48cb350f,hi:0};assert(core_div(Cbig_1,Cbig_3)==Cb1divb3);assert(udiv(Cbig_1,Cbig_3)==Cb1udivb3);assert(core_mul(Cm10,C1)==Cm10);assert(core_mul(C1,Cm10)==Cm10);assert(core_mul(C9_3,C10)==C90_30);assert(core_mul(Cs_3,C10)==C30);assert(core_mul(Cm10,Cm10)==C100);assert(core_mul(C20_0,Cm1)==Cm20_0);assert(core_or(C4_8,C3_1)==C7_9);assert(core_and(C4_8,C7_9)==C4_8);assert(core_xor(C4_8,C7_9)==C3_1);assert(rol(Cm1,1)==Cm1);assert(ror(Cm1,45)==Cm1);assert(rol(ror(C7_9,5),5)==C7_9);assert(rol(C7_9,1)==rol1(C7_9));assert(ror(C7_9,1)==ror1(C7_9));}}
